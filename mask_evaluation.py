# This file has 3 functions: resample_and_normalize_masks(), dice_score(), calculate_dice_scores().
# The newly created masks from TotalSegmentator are compared with the 'older' masks with the DICE score

import numpy as np
import nibabel as nib
import os
import nibabel.processing


import nibabel as nib
import numpy as np
import nibabel.processing

def resample_and_normalize_masks(output_directory):
    """
    Received masks are normalized and resampled and saved in output directory.
    Like this both the new masks and the 'older' masks are comparable.
    """
    
    # Load the original mask and the ground truth mask (with different resolution)
    mask = nib.load('masks_heart/16-1217_5_0_B31S.nii/heart.nii.gz')
    mask_andrea = nib.load('masks_andrea_uncropped/16-1217_label.nii.gz')

    # Get the data from Andreas' mask and normalize it (convert -3024 to 0)
    mask_andrea_data = mask_andrea.get_fdata()
    
    # Replace -3024 with 0 (background) and ensure that the mask is binary (0 and 1)
    mask_andrea_data[mask_andrea_data == -3024] = 0
    mask_andrea_data[mask_andrea_data != 0] = 1  # Ensure the foreground remains 1
    
    # Create a new NIfTI image with the normalized data
    normalized_mask_andrea = nib.Nifti1Image(mask_andrea_data, mask_andrea.affine)

    # Resample the normalized ground truth mask to match the mask generated by TotalSegmentator
    resampled_mask = nibabel.processing.resample_from_to(normalized_mask_andrea, mask, order=0)  # Nearest neighbor interpolation
    
    # Get the data from the resampled mask and the original mask
    resampled_mask_data = resampled_mask.get_fdata()
    mask_data = mask.get_fdata()

    # Check the unique values to ensure they are binary (0 or 1)
    print('Normalized and resampled mask values:', np.unique(resampled_mask_data))
    print('Original mask values:', np.unique(mask_data))

    # Optionally save the resampled ground truth mask if needed
    nib.save(resampled_mask, output_directory)

    print('Resampling and normalization done, new shape:', resampled_mask_data.shape)



    
    
    
def dice_score(predicted_mask, ground_truth_mask):
    
    """
    Calculate the Dice Similarity Coefficient between two binary masks.
    
    Args:
        predicted_mask (numpy.ndarray): The predicted binary mask.
        ground_truth_mask (numpy.ndarray): The ground truth binary mask.
        
    Returns:
        float: Dice similarity coefficient (DSC) between the two masks.
    """
    
    # Ensure both masks are binary
    predicted_mask = (predicted_mask > 0).astype(np.uint8)
    ground_truth_mask = (ground_truth_mask > 0).astype(np.uint8)

    # Compute intersection and Dice score
    intersection = np.sum(predicted_mask * ground_truth_mask)
    dice = (2. * intersection) / (np.sum(predicted_mask) + np.sum(ground_truth_mask))
    
    return dice



def calculate_dice_scores(mask_directory, ground_truth_directory):
    
    """
    Calculate Dice scores between predicted masks and ground truth masks.
    
    Args:
        mask_directory (str): Path to directory containing predicted binary masks.
        ground_truth_directory (str): Path to directory containing ground truth masks.
        
    Returns:
        list: A list of Dice scores for each pair of predicted and ground truth masks.
        float: The average Dice score across all segmentations.
    """
    
    dice_scores = []  # List to store Dice scores
    
 
    predicted_mask_path = os.path.join(mask_directory, '16-1217_5_0_B31S.nii/heart.nii.gz')
    ground_truth_mask_path = os.path.join(ground_truth_directory, 'test.nii.gz')
            
            
    # Load the predicted and ground truth masks
    predicted_img = nib.load(predicted_mask_path)
    ground_truth_img = nib.load(ground_truth_mask_path)
            
    predicted_mask_data = predicted_img.get_fdata()
    ground_truth_mask_data = ground_truth_img.get_fdata()
            
    # Calculate Dice score
    dice = dice_score(predicted_mask_data, ground_truth_mask_data)
    dice_scores.append(dice)

    
    # Calculate the average Dice score across all segmentations
    avg_dice = np.mean(dice_scores)
    
    print(dice_scores)
    print(f'Average Dice score across all segmentations: {avg_dice}')
    
    return dice_scores, avg_dice




if __name__ == '__main__':
    
    mask_directory = 'masks_heart/'  # Directory containing predicted segmentation masks
    ground_truth_directory = 'ground_truth_masks/'  # Directory containing ground truth masks
    
    
    # Run the function
    resample_and_normalize_masks('ground_truth_masks/test.nii.gz')  
    
    
    # Calculate Dice scores for all masks
    dice_scores, avg_dice = calculate_dice_scores(mask_directory, ground_truth_directory)

    