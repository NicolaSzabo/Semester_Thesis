import numpy as np
import nibabel as nib
import os
import nibabel.processing


def resample_and_normalize_masks(new_mask_directory, compare_mask_directory, output_directory):
    """
    Received masks are normalized and resampled and saved in output directory.
    Like this both the new masks and the 'older' masks are comparable.
    """
    
    new_mask_files = [f for f in os.listdir(new_mask_directory) if f.endswith('.nii.gz')]
    compare_mask_files = [f for f in os.listdir(compare_mask_directory) if f.endswith('.nii.gz')]
                
                    
    for new_mask_filename, comparable_mask_filename in zip(new_mask_files, compare_mask_files):
        
        new_mask_path = os.path.join(new_mask_directory, new_mask_filename)            
        compare_mask_path = os.path.join(compare_mask_directory, comparable_mask_filename)

        # Load the original mask and the ground truth mask (with different resolution)
        mask = nib.load(new_mask_path)
        mask_compare = nib.load(compare_mask_path)
        print(mask_compare.shape)            
                    
        # Get the data from mask and normalize it (convert -3024 to 0)
        mask_compare_data = mask_compare.get_fdata()
    
        # Replace -3024 with 0 (background) and ensure that the mask is binary (0 and 1)
        mask_compare_data[mask_compare_data == -3024] = 0
        mask_compare_data[mask_compare_data != 0] = 1  # Ensure the foreground remains 1
    
        # Create a new NIfTI image with the normalized data
        normalized_mask_compare = nib.Nifti1Image(mask_compare_data, mask_compare.affine)

        # Resample the normalized ground truth mask to match the mask generated by TotalSegmentator
        resampled_mask = nibabel.processing.resample_from_to(normalized_mask_compare, mask, order = 0)
                    
        output_filename = f'resampled_{new_mask_filename}'  # Prefix 'resampled_' to the original filename
        output_path = os.path.join(output_directory, output_filename)  
    
        # Get the data from the resampled mask and the original mask
        resampled_mask_data = resampled_mask.get_fdata()
        mask_data = mask.get_fdata()

        # Check the unique values to ensure they are binary (0 or 1)
        print('Normalized and resampled mask values:', np.unique(resampled_mask_data))
        print('Original mask values:', np.unique(mask_data))

        # Optionally save the resampled ground truth mask if needed
        nib.save(resampled_mask, output_path)

        print('Resampling and normalization done, new shape:', resampled_mask_data.shape)


                    
                

if __name__ == '__main__':
    
    new_mask_directory = 'masks_heart/'  # Directory containing predicted segmentation masks
    compare_mask_directory = 'masks_compare/'  # Directory containing ground truth masks
    output_directory = 'ground_truth_masks/'
    
    
    # Run the function
    resample_and_normalize_masks(new_mask_directory, compare_mask_directory, output_directory) 